WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

Program = { SOI ~ Statement+ ~ EOI }

Statement = { Assignment ~ ";" }

Assignment = { "let" ~ Identifier ~ (":" ~ Type)? ~ "=" ~ Expression }

Expression = { 
    IntegerLiteral | 
    BooleanLiteral | 
    // Write function calls before identifiers so the arguments get matched.
    FunctionCall |
    Identifier |
    BinaryExpression |
    UnaryExpression
}

BinaryExpression = { "(" ~ BinaryOperator ~ Expression ~ Expression ~ ")" }

BinaryOperator = @{
    "+" | "-" | "*" | "/" |
    "==" | "!=" |
    // 'or equal to' versions of relation operations must come first
    // before their strict versions to avoid parsing errors because PEGs
    // stop on the first match they found, so always put the longer versions
    // first before the shorter ones.
    "<=" | "<" | ">=" | ">" |
    "or" | "and"
}

UnaryExpression = { "(" ~ UnaryOperator ~ Expression ~ ")" }

UnaryOperator = { "-" | "not" }

FunctionCall = @{ Identifier ~ "()" }

IntegerLiteral = @{ ASCII_DIGIT+ }

BooleanLiteral = @{ "true" | "false" }

Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

Type = @{ "Number" | "Boolean" }